{"name":"Aroma Mock","tagline":"JavaScript automatic Mock objects with Scenarios: test *exactly* what you want","body":"# AromaMock - Mocking Framework for JavaScript and CoffeeScript\r\n\r\nAroma is a CoffeeScript Mock Framework. This of course means that it *can* be\r\nused to test and develop JavaScript, but in this document, I will address\r\nCoffeeScript, because I like it better. It provides a useful\r\nscenario-expectations construct and easy, on the fly mock object generation.\r\n\r\nThe scenario verifies the exact expected function call sequence including the\r\nfunction arguments. Scenarios are specified before the code is run, making the\r\ntests well organized, readable and more explicit. \r\n\r\nThe scenario abstraction verifies that things happen *exactly* as specified:\r\ni.e. we do not only verify that some mock function was called with specific\r\nparamenter, we verify that it has *not* been called more times that it should\r\nhave been, with some other parameters.\r\n\r\nOriginal concepts were carried over from [Voodoo-Mock](http://github.com/shlomimatichin/Voodoo-Mock), a C++/Python unit test\r\nframework.\r\n\r\n## Installation\r\n\r\n\t$ npm install aroma-mock\r\n\r\nYou will also probably want to\r\n\r\n\t$ npm install mocha coffee-script\r\n\r\n## Running CoffeeScript Tests with Mocha\r\n\r\nIn the following examples I use [Mocha](http://mochajs.org) for a test runner.\r\nIn order for Mocha to work with CoffeeScript you must use it like this:\r\n\r\n\t$ mocha --compilers coffee:coffee-script/register [tests...]\r\n\r\n## Using Aroma-Mock with JavaScript\r\n\r\nAroma-Mock is written in CoffeeScript. It can be used in JavaScript by requiring the `coffee-script/register` in your test code, and then requiring `aroma-mock`:\r\n\r\n## Quick Start\r\nHere's an example test, that mocks the jQuery $ symbol and tests that it is\r\nused as expected.  Before reading the entire thing, let's just look at the `call` expectation: \r\n\r\n\tcall( '$', [ \"#input_element\" ], fakeObject( 'element', ['val'] ) )\r\n\r\nexpresses our expectation that the tested code will call `$` with\r\n`\"#input_element\"` as its first argument. We also arrange that the return value\r\nof this call will be a Mock Object called `element`.  \r\n\r\nWe *then* expect that this `element` object's `val` method will be called with\r\none argument, the string `'123'`. This is expressed in the expectation:\r\n\r\n\tcall( 'element.val', [ '123' ] )\r\n\r\nSince we don't care about the return value from this call, we leave it unspecified. We can also use `null`\r\n\r\n\tcall( 'element.val', [ '123' ], null )\r\n\r\nSince jQuery expectations are commonplace, we can use the shorthand\r\n`expect_$` for this 2-call expectation - this is demonstrated below.\r\n\t\r\nAnother thing to note is the use of `capture` and `captured` to test functions\r\ncalled with callbacks. E.g., if our code calls `fs.mkdir( 'somepath', onCreated\r\n)`, we want to later call this `onCreated` function. We therefore use the\r\n`capture` feature of Aroma-Mock to get at it:\r\n\r\n    call( 'fs.mkdir', [ 'somepath', capture( 'onCreatedCallback' ) ] )\r\n\r\nand later call it via the `captured` API:\r\n\r\n    captured.onCreatedCallback()\r\n\r\nI hope this makes the following, complete listing, clear.\r\n\r\n\r\n```coffeescript\r\nrequire 'aroma-mock' # import the Aroma-Mock framework\r\nexample = require '../example'\r\n\r\nfakeGlobal( '$', [ 'getJSON', 'ajax' ] )\r\nfakeGlobal( 'Point', [] )\r\n\r\ndescribe 'example of aroma mocking framework', ->\r\n\tit 'should get JSON with jQuery', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tscenario.expect call( '$.getJSON', [ 'www.google.com', {a:1, b:2}, capture( 'doneCallback' ) ], null )\r\n\r\n\t\ttested.getSomeJSON()\r\n\t\tscenario.end()\r\n\r\n\t\tcaptured.doneCallback()\r\n\r\n\tit 'should use jQuery on the DOM', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tscenario.expect call( '$', [ \"#input_element\" ], fakeObject( 'element', ['val'] ) )\r\n\t\tscenario.expect call( 'element.val', [ '123' ], null )\r\n\t\ttested.useJQueryOnDOM( '123' )\r\n\t\tscenario.end()\r\n\r\n\tit 'should use jQuery on the DOM: example of expect_$ shorthand notation', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tscenario.expect_$( '#input_element', 'val', [ '456' ], null )\r\n\t\ttested.useJQueryOnDOM( '456' )\r\n\t\tscenario.end()\r\n```\r\n\r\nhere's the code that passes this test:\r\n```coffeescript\r\nclass Example\r\n\tuseJQueryOnDOM: ( text ) =>\r\n\t\t$(\"#input_element\").val( text )\r\n\r\n\tgetSomeJSON: =>\r\n\t\t$.getJSON 'www.google.com', {a:1,b:2}, this._mycallback\r\n\r\n\t_mycallback: =>\r\n\t\tconsole.log( 'my callback called!' )\r\n\r\nexports.Example = Example\r\n```\r\n\r\n## Asynchronous Ajax JSON Retrieval Example\r\nThe `AjaxTest` class allows testing for an asynchronous ajax call. We define\r\nthe parameters of the ajax call, the data supposedly returned from the server,\r\nand what we expect should happen on success.\r\n\r\nHere's an asynchronous ajax test:\r\n\r\n```coffeescript\r\n\r\n# we don't use getJSON in this example, but this is how to create a fake object\r\n# with multiple methods.\r\nfakeGlobal( '$', [ 'getJSON', 'ajax' ] )\r\n\r\ndescribe 'example of aroma ajax mocking', ->\r\n\tit 'aroma can test asynchronous AJAX', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tajaxTest = new AjaxTest( scenario )\r\n\t\tajaxTest.expect( { url: '/path/to/return_keys.json', data: { a: 1, b: 2 }, type: 'POST' } )\r\n\t\tajaxTest.returnFromServer( { status: 'ok', answer: [ 'a', 'b' ] } )\r\n\t\tajaxTest.onSuccessScenario = =>\r\n\t\t\tscenario.expect_$( \"#status\", 'val', [ 'ok' ], null )\r\n\t\t\tscenario.expect_$( \"#output_element\", 'val', [ [ 'a', 'b' ] ], null )\r\n\r\n\t\ttested.doAsyncAjax( { a: 1, b: 2 } )\r\n\t\tajaxTest.verify()\r\n\t\tscenario.end()\r\n```\r\n\r\nthis is the code that passes it\r\n\r\n```coffeescript\r\nclass Example\r\n\tdoAsyncAjax: ( data ) =>\r\n\t\tsuccess = (data) =>\r\n\t\t\t$(\"#status\").val( data.status )\r\n\t\t\t$(\"#output_element\").val( data.answer )\r\n\t\t$.ajax { url: '/path/to/return_keys.json', data: data, type: 'POST', success: success }\r\n```\r\n\r\na test that checks the response to an error can also be written\r\n\r\n\r\n```coffeescript\r\n\r\n# we don't use getJSON in this example, but this is how to create a fake object\r\n# with multiple methods.\r\nfakeGlobal( '$', [ 'getJSON', 'ajax' ] )\r\n\r\ndescribe 'example of aroma ajax mocking', ->\r\n\tit 'aroma asynchronous AJAX error example', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tajaxTest = new AjaxTest( scenario )\r\n\t\tajaxTest.expect( { url: '/path/to/return_keys.json', data: { a: 1, b: 2 }, type: 'POST' } )\r\n\t\tajaxTest.errorFromServer( null, 'error text 123', null )\r\n\t\tajaxTest.onErrorScenario = =>\r\n\t\t\tscenario.expect_$( \"#status\", 'val', [ 'error text 123' ], null )\r\n\t\t\tscenario.expect_$( \"#output_element\", 'val', [ [] ], null )\r\n\r\n\t\ttested.doAsyncAjax( { a: 1, b: 2 } )\r\n\t\tajaxTest.verify( 'error' )\r\n\t\tscenario.end()\r\n```\r\n\r\nThis code passes the test, as well as the previous one:\r\n\r\n```coffeescript\r\nclass Example\r\n\tdoAsyncAjax: ( data ) =>\r\n\t\tsuccess = (data) =>\r\n\t\t\t$(\"#status\").val( data.status )\r\n\t\t\t$(\"#output_element\").val( data.answer )\r\n\t\terror = ( unused, text, unused2 ) =>\r\n\t\t\t$(\"#status\").val( text )\r\n\t\t\t$(\"#output_element\").val( [] )\r\n\t\t\t\r\n\t\t$.ajax { \turl: '/path/to/return_keys.json',\\\r\n\t\t\t\t\tdata: data,\r\n\t\t\t\t\ttype: 'POST',\r\n\t\t\t\t\tsuccess: success,\r\n\t\t\t\t\terror: error }\r\n```\r\n\r\n## The Callback Cascade Pattern\r\n\r\nWhen writing JavaScript code, it often happens that we get a cascade of\r\ncallback functions, since almost everything is done asynchronously.  For\r\nexample, say we want to check if some directory exists, and if not, create it,\r\nand then run some subprocess in the directory. If the directory already exists,\r\nwe don't need to create it.\r\n\r\nThe callback cascade here is\r\n\r\n    fs.exists => fs.mkdir => childProcess.exec\r\n\r\nWe can use `capture` for this, but it gets ugly really fast. If the callback\r\nargument for each function in our cascade is the *last* one, which is often the\r\ncase, e.g.\r\n\r\n    fs.exists(path, callback)\r\n\r\nWe can use the *cascade* pattern:\r\n\r\n```coffeescript\r\nrewire = require 'rewire'\r\n\r\ndescribe 'cascade of callbacks', ->\r\n    beforeEach ->\r\n        cascadeModule.__set__( 'fs', fakeObject( 'fs', [ 'exists', 'mkdir' ] ) )\r\n        cascadeModule.__set__( 'childProcess', fakeObject( 'childProcess', [ 'exec' ] ) )\r\n\r\n    it 'should work', ->\r\n        myCallback = fakeObject( 'myCallback' )\r\n        scenario.expectCascade [    cascade( 'fs.exists', [ 'some_path' ], null, [false] ),\r\n                                    cascade( 'fs.mkdir', [ 'some_path' ] ),\r\n                                    cascade( 'childProcess.exec', [ 'some command', {cwd: 'some_path'} ], null, [ null, \"output string\", \"error string\" ] ),\r\n                                    call( 'myCallback', [ \"output string\" ] ) ]\r\n\r\n        tested = new cascadeModule.Cascade()\r\n\r\n        tested.go( 'some_path', myCallback )\r\n        scenario.end()\r\n        \r\n```\r\n\r\nNOTE the use of [*rewire*](https://github.com/jhnns/rewire) to mock objects inside the module.\r\n\r\nThis expresses the expectation that the code will call `fs.exists` - passing it\r\n`some_path`. The `fs.exists` cascade specifies that `fs.exists` will return\r\n`null`, *and then* call its callback with the arguments specified in a list, in\r\nthis case `[false]`, so just one argument.\r\n\r\nWhat happens when `fs.exists`'s callback is called? Since the directory does\r\nnot exist (we made `fs.exists` pass `false` to its callback, remember?) we\r\nexpect it to call `fs.mkdir`, which will the call *its* callback.\r\n\r\nWe then demand that this callback call `childProcess.exec` and we specify the\r\noutput and error strings passed to *its* callback, which should, finally, call\r\nthe user's callback.\r\n\r\nNOTE the last call in the cascade is a `call`, not a `cascade` - since we don't\r\nwant it to automatically call a callback.\r\n\r\nThe code that passes this test would be:\r\n```coffeescript\r\nfs = require 'fs'\r\nchildProcess = require 'child_process'\r\n\r\nclass Cascade\r\n    go: ( path, callback ) =>\r\n        @callback = callback\r\n        fs.exists path, (exists) =>\r\n            if exists\r\n                this._runChild( path )\r\n            else\r\n                fs.mkdir path, =>\r\n                    this._runChild( path )\r\n\r\n    _runChild: ( path ) =>\r\n        childProcess.exec 'some command', { cwd: path }, (err, output, error) =>\r\n            @callback( output )\r\n\r\nexports.Cascade = Cascade\r\n```\r\n","google":"UA-59792836-1","note":"Don't delete this file! It's used internally to help with page regeneration."}