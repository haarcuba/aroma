{"name":"Aroma","tagline":"CoffeeScript automatic Mock objects with Scenarios: test *exactly* what you want","body":"# Aroma - Mocking Framework for Coffee Script\r\n\r\nAroma is a Coffee Script Mock Framework. It provides a useful scenario-expectations construct and easy, on the fly mock object generation.\r\n\r\nThe scenario verifies the exact expected function call sequence including the function arguments. Scenarios are specified before the code is run, making the tests well organized, readable and more explicit. \r\n\r\nThe scenario abstraction verifies that things happen *exactly* as specified: i.e. we do not only verify that some mock function was called with specific paramenter, we verify that it has *not* been called more times that it should have been, with some other parameters.\r\n\r\nOriginal concepts were carried over from Voodoo-Mock, a C++/Python unit test framework.\r\n\r\n\r\n## Example\r\nHere's an example test, that mocks the jQuery $ symbol and tests that it is used as expected. \r\nThe `call` expectation: \r\n\r\n\tcall( '$', [ \"#input_element\" ], fakeObject( 'element', ['val'] ) )\r\n\r\nexpresses our expectation that the tested code will call `$` with `\"#input_element\"` as its first argument. We also arrange that\r\nthe return value of this call will be a Mock Object called `element`.\r\nWe *then* expect that this `element` object's `val` method will be called with the expectation:\r\n\r\n\tcall( 'element.val', [ '123' ], null )\r\n\r\nSince we don't care about the return value from this call, we used `null`.\r\n\r\nSince JQuery expectations are commonplace, we can use a the shorthand `expect_$` for this 2-call expectation - this is demonstrated below.\r\n\t\r\n\r\nI hope this makes the following, complete listing, clear.\r\n\r\n\r\n```coffeescript\r\nrequire 'globals' # import the Aroma test suite\r\nexample = require '../example'\r\n\r\nfakeGlobal( '$', [ 'getJSON', 'ajax' ] )\r\nfakeGlobal( 'Point', [] )\r\n\r\ndescribe 'example of aroma mocking framework', ->\r\n\tit 'should get JSON with jQuery', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tscenario.expect call( '$.getJSON', [ 'www.google.com', {a:1, b:2}, new SaveArgument( 'doneCallback' ) ], null )\r\n\r\n\t\ttested.getSomeJSON()\r\n\t\tscenario.end()\r\n\r\n\t\tcapturedCallback = SaveArgument.saved( 'doneCallback' )\r\n\t\tcapturedCallback()\r\n\r\n\tit 'should use jQuery on the DOM', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tscenario.expect call( '$', [ \"#input_element\" ], fakeObject( 'element', ['val'] ) )\r\n\t\tscenario.expect call( 'element.val', [ '123' ], null )\r\n\t\ttested.useJQueryOnDOM( '123' )\r\n\t\tscenario.end()\r\n\r\n\tit 'should use jQuery on the DOM: example of expect_$ shorthand notation', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tscenario.expect_$( '#input_element', 'val', [ '456' ], null )\r\n\t\ttested.useJQueryOnDOM( '456' )\r\n\t\tscenario.end()\r\n```\r\n\r\nhere's the code that passes this test:\r\n```coffeescript\r\nclass Example\r\n\tuseJQueryOnDOM: ( text ) =>\r\n\t\t$(\"#input_element\").val( text )\r\n\r\n\tgetSomeJSON: =>\r\n\t\t$.getJSON 'www.google.com', {a:1,b:2}, this._mycallback\r\n\r\n\t_mycallback: =>\r\n\t\tconsole.log( 'my callback called!' )\r\n\r\nexports.Example = Example\r\n```\r\n\r\n## Asynchronous Ajax JSON Retrieval Example\r\nThe `AjaxTest` class allows testing for an asynchronous ajax call. We define\r\nthe parameters of the ajax call, the data supposedly returned from the server,\r\nand what we expect should happen on success.\r\n\r\nCurrently, it is assumed that the call is successful - an option for failure\r\nwill be added in the future when I need it :)\r\n\r\nHere's an asynchronous ajax test:\r\n\r\n```coffeescript\r\n\r\n# we don't use getJSON in this example, but this is how to create a fake object\r\n# with multiple methods.\r\nfakeGlobal( '$', [ 'getJSON', 'ajax' ] )\r\n\r\ndescribe 'example of aroma ajax mocking', ->\r\n\tit 'aroma can test asynchronous AJAX', ->\r\n\t\ttested = new example.Example()\r\n\t\tscenario = new Scenario()\r\n\t\tajaxTest = new AjaxTest( scenario )\r\n\t\tajaxTest.expect( { url: '/path/to/return_keys.json', data: { a: 1, b: 2 }, type: 'POST' } )\r\n\t\tajaxTest.returnFromServer( { status: 'ok', answer: [ 'a', 'b' ] } )\r\n\t\tajaxTest.onSuccess = =>\r\n\t\t\tscenario.expect_$( \"#status\", 'val', [ 'ok' ], null )\r\n\t\t\tscenario.expect_$( \"#output_element\", 'val', [ [ 'a', 'b' ] ], null )\r\n\r\n\t\ttested.doAsyncAjax( { a: 1, b: 2 } )\r\n\t\tajaxTest.verify()\r\n\t\tscenario.end()\r\n```\r\n\r\nthis is the code that passes it\r\n\r\n```coffeescript\r\nclass Example\r\n\tdoAsyncAjax: ( data ) =>\r\n\t\tsuccess = (data) =>\r\n\t\t\t$(\"#status\").val( data.status )\r\n\t\t\t$(\"#output_element\").val( data.answer )\r\n\t\t$.ajax { url: '/path/to/return_keys.json', data: data, type: 'POST', success: success }\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}